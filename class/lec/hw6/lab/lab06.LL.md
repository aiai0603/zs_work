# **2020-21学年第2学期**

## **实 验 报 告**

![zucc](zucc.png){width="1.5208333333333333in" height="1.5208333333333333in"}

-   课程名称:编程语言原理与编译

-   实验项目: 语法分析 LL 分析

-   专业班级\_\_\_计算机1803

-   学生学号\_\_\_31801150

-   学生姓名\_\_\_张帅

-   实验指导教师:郭鸣

## 实验内容

1. 本次实验有下次课内容
  - LL（1）分析表构造，等下次课一起提交
  - 先完成First Follow 集计算部分

2. 阅读ppt 相关内容 ，阅读教材第3章

- 理解Nullable集、First集、 Follow集 概念
    - 阅读 `NullableFirstFollow.pdf` 
    
    - 理解 各个集合的构造方法
    
      NULLABLE集合：可以推导出空串的非终结符的集合（属于NULLABLE集合意味着不用接受任何输入即可跳过该非终结符）
    
      【1】若右边含有ε ，则直接将其加入 NULLABLE集合
    
      【2】若右边符号在NULLABLE集合中，则将其加入加入 NULLABLE集合
    
      
    
      FIRST集合：FIRST(α)被定义为从 α 推导得到的句子的首符号的集合，α 是任意的文法符号串。
    
      【1】若右边第一个符号是终结符或 ε ，则直接将其加入 First（X）
    
      【2】若右边第一个符号是非终结符，则将其 First 集的的非 ε 元素加入 First（X）
    
      【3】若右边第一个符号是非终结符而且紧随其后的是很多个非终结符，这个时候就要注意是否有 **ε** 。
    
      【3.1】若第 i 个非终结符的 First 集有 ε ，则可将第 i+1 个非终结符去除 ε 的 First 集加入 First（X）。
    
      【3.2】若所有的非终结符都能够推导出 ε ，则将 ε 也加入到 First（X）
    
       
    
      FOLLOW集合：对于非终结符A，FOLLOW(A)被定义为可能在某些句型中紧跟在A右边的终结符号的集合
    
      【1】将所有产生式的候选式（即产生式右部）的非终结符都找到，定位到你想要求解 Follow 集的非终结符的位置，从当前位置往后挨个检查。设 A -> aBC 是一个产生式，在这个产生式中， B 和 C 是非终结符，a 是终结符
    
      【2】先检验这个非终结符的右边还有没有别的符号（终结符或非终结符都可以），在例子中 B 是需要检查的第一个非终结符，它的右边是有非终结符 C 的。
    
      【2.1】若右边有符号 -> 将 First（右侧第一个符号）的非 ε 集合加入到 Follow（当前符号）中，如果 First（右侧第一个符号）含有 ε ，即有 ... -> ε ，则将 Follow（产生式左部符号）加入 Follow（当前符号）中。
    
      【2.2】若右边没有符号了，例如这里的 C，那么可以将 Follow（A）中的元素全部加入到 Follow（C）中。
    
      【3】判断当前符号是不是文法的开始符号，比如 G[A] 中的非终结符 A 就是 G[A] 文法的开始符号，如果是的话就将“#”也加入到 Follow（当前符号）中去。
    
      
    
- 理解  自顶向下分析，自底向上分析的区别

    自顶向上：它的实现思想是对输入符号串自左向右进行扫描，并将输入符逐个移入一个后进先出栈中，边移入边分析，一旦栈顶符号串形成某个句型的句柄时，(该句柄对应某产生式的右部)，就用该产生式的左部非终结符代替相应右部的文法符号串，这称为一步归约。重复这一过程直到归约到栈中只剩文法的开始符号时则为分析成功，也就确认输入串是文法的句子。
    

    自顶向下：是从某文法的开始符号出发，考虑如何根据当前的输入符号(单词符号)唯一地确定选用哪个产生式替换相应非终结符往下推导，或如何构造一棵相应的语法树，其末端结点以从左向右的顺序连接正好为给定的输入符号串，则所给的输入符号串为该文法的句子。

    

- 理解确定性自顶向下分析方法，`LL(1)`分析
    - 第一个L 第二个L，数字1 各是什么含义
    
      L 从左到右扫描Token序列
    
      L 构造分析树采用最左推导
    
      (1)向前查看一个Token
    
      
    
    - `LL(1)` 预测分析表构造，中 与`First`集 `Follow`集的关系,
    
      计算Follow集需要先计算First集
    
      First: 在给定输入符号和待推导非终结符号的情况下，用于寻找正确的产生式规则。
      例如: 假设存在规则A→α，a是First(α)中的元素，那么，当输入符号是a的时候，选择该规则，将待推导非终结符号A替换为α。(a是α所能推导出来的第一个符号，所以，当输入是a，且A是待推导的符号时，用A→α进行推导)
      Follow: 如果A→α，当α*ε时，则可以跟在A后面的符号代表了要选择该规则进行推导。
      例如: 假设A→α，b是Follow(A)中的元素，则当α*ε，且b为当前输入符号时，我们用A→α进行推导。
    
      Follow: 如果A→α，当α*ε时，则可以跟在A后面的符号代表了要选择该规则进行推导。
      例如: 假设A→α，b是Follow(A)中的元素，则当α*ε，且b为当前输入符号时，我们用A→α进行推导。
    
      对任意A 有如下3个形式：
       0: A = f1
      1: A = f1 | ... | fn
       2: A = f1 | ... | fn | ε           
      为了得到确定的推导，要求有：
    
      1. 对任意 fi   fj  有First(fi) ∩ First(fj) = {} ,确保每个可选的推导分支 可以用First集区分
    
      2. 当有ε  规则, First(fi) ∩ Follow(A) = {}
    
      3. 确保每个可选的推导规则 可以用First集、Follow集区分
    
        
    
    - 阅读`NullableFirstFollow.pdf`理解分析表的构造
    
      分析表是一个二维数组 M[A，a]，其中 A 表示行，是非终结符，a 表式列是终结符或 #。
    
      M[A，a] 中若有产生式，表明 A 可用该产生式推导，以求与输入符号 a 匹配。
      M[A，a] 中若为空，表明 A 不可能推导出与 a 匹配的字符串
      LL(1) 分析表构造方法:
    
      若 a∈SELECT(A→α)，则把 A→α 加至 M[A, a] 中
      把所有无定义的 M[A, a] 标上“出错标志”。
    
      
    
- 理解  通过关系图计算First集 Follow集的方法

    关系图法求First集

    (a)每个文法符号对应图中一个结点，对应终结符的结点时用
    符号本身标记，对应非终结符的结点用First(A)标记。这里A表示非终结符
    (b)如果文法中有产生式A→αXβ，且α → ε,则从对应A的结点到对应X的结点连一条箭弧

    (c)凡是从First(A)结点有路径可到达的终结符结点所标记的
    终结符都为First(A)的成员

    (d)由判别步骤1）确定ε是否为某非终结符First集的成员，
    若是则将ε加入该非终结符的First集中

    

    关系图法求非终结符的Follow集

    (a)文法G中的每个符号和“#”对应图中的一个结点，对应终结符和“#”的结点用符号本身标记。对应非终结符的结点(如A∈VN)则用Follow(A)或First(A)标记
    (b)从开始符号S的Follow(S)结点到“#”号的结点连一条箭弧
    (c)如果文法中有产生式A→αBβX,且β → ε,则从Follow(B)结点到First(X)结点连一条弧，当X∈VT时，则与X相连
    (d) 如果文法中有产生式A→αBβ,且β → ε，则从Follow(B)结点到Follow(A)结点连一条箭弧(e) 对每一First(A)结点如果有产生式A→αXβ,且α → ε, 则从First(A)到First(X)连一条箭弧
    (f)凡是从Follow(A)结点有路径可以到达的终结符或“#”号的结点，其所标记的终结符或"#"号即为Follow(A)的成员

    

- 理解  递归下降分析程序与文法的对应关系

- 通过学习可视化工具，理解`LL(1)`分析算法
    - [LL(1)可视化](https://www.cs.princeton.edu/courses/archive/spring20/cos320/LL1/)
    - [在线分析工具 grammophone](http://mdaines.github.io/grammophone/)
      - 可以检查作业，不要抄
      - 招募学生，改进该工具，有兴趣的学生直接联系教师

2. 请问如下语言可以用 正则表达式描述吗?为什么?

   正则表达式等价于3型文法，只具有相当于有限自动机的表达能力，而匹配不确定数量的括号对至少需要一个栈，需要用相当于下推自动机的2型文法。

```sh
 L = { ((( ... )))(( ... )) | 括号是配对的 }
```

3. 设有文法

```sh
 S -> a | ^ |( T ) .
 T -> T , S | S .
```
请消除文法的左递归。

S -> a | ^ |( T ) .

T'->  , ST’ | ε .

T -> ST'.

4. 设有文法

```sh
E -> T | T ^ E .
T -> int * T | ( E ) | ( S ) .
S -> int T .
```

**请提取文法的左公因子。**

E ->  TX  .

X ->  ^ E | ε  .

T ->  int T | ( Y  .

Y ->  E ) | S )  .

S -> int * T.

5. 设有如下文法

   <h1>TIPS:原题存在问题，不可能转化为LL(1)文法，经过搜索得到可能的正确题干如下：</h1>

```sh
S -> A .

A -> B | AiB .

B -> C | B+C .

C -> ) A * | ( .
```

- 将文法改为 LL（1）文法

  S  -> A.

  A  -> B A'.

  A' -> i B A' | ε .

  B  -> C B'.

  B' -> + C B' | ε.

  C -> ) A * | ( .

  

- 求每个非终结符的 `First`集 与 `Follow`集

|      | First集 | Follow集   |
| ---- | ------- | ---------- |
| S    | ）,（   | #          |
| A    | ）,（   | *，#       |
| A'   | i       | *，#       |
| B    | ）,（   | i，*，#    |
| B'   | +       | i，*，#    |
| C    | ）,（   | +，i，*，# |

- 构造 LL（1）预测分析表

  |      | +    | *    | (    | )    | i    | #    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | S    |   |          | S  -> A. | S  -> A. | | |
| A    |    |       | A  -> B A'. | A  -> B A'. | | |
| A'   |      |        | A' ->  ε . | | A' -> i B A'. | A' -> ε . |
| B    |    |     | B  -> C B'. | B  -> C B'. | | |
| B'   | B' -> + C B'. | B' ->  ε. | | | B' ->  ε. | B' ->  ε. |
| C    |  |  | C -> (  . | C -> ) A * . | | |
  
  
  
  

6. 给定以下文法

```sh
S -> + S S . 
S -> * S S . 
S -> a .
```

- 给出该文法的预测分析表

  |      | FIRST集 | FOLLOW集   |
  | ---- | ------- | ---------- |
  | S    | +，a，* | +，a，*，# |

  |      | +            | *            | a        | #    |
  | ---- | ------------ | ------------ | -------- | ---- |
  | S    | S -> + S S . | S -> * S S . | S -> a . |      |

- 利用预测分析器算法分析`+*aaa`，判断该句子是否属于上面文法的语言。

| 栈    | 输入   | 输出         |
| ----- | ------ | ------------ |
| #S    | +*aaa# |              |
| #SS+  | +*aaa# | S -> + S S . |
| #SS   | *aaa#  |              |
| #SSS* | *aaa#  | S -> * S S . |
| #SSS  | aaa#   |              |
| #SSa  | aaa#   | S -> a .     |
| #SS   | aa#    |              |
| #Sa   | aa#    | S -> a .     |
| #S    | a#     |              |
| #a    | a#     | S -> a .     |
| #     | #      |              |



### 提交方式

- 打包`zip`上传到`bb`

- 实验报告采用`Markdown`格式

- `zip`内容包括`Markdown`文本、代码、部分体现实验过程的典型截屏(`.png`格式)

  